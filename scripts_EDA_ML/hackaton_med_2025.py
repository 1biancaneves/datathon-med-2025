# -*- coding: utf-8 -*-
"""Hackaton - MeD 2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JR57q0fcsh5qa6lYXdlAbH7c8tkjr4fL

## Prazo e Critérios de Avaliação


### Critério

1. Perguntas de múltipla escolha sobre a base.
2. Dataset(s) tratado (s).
3. Relatório de tratamento e análise descritiva dos dados.


### Prazo

Formulário: **dia 09/10 até as 23:59**.
Obs.: somente 1 envio por equipe e será considerado o primeiro envio.

# Desafio

*   **Como podemos ver o potencial do aluno comparando-o com o de outros alunos que tiveram um perfil e condições semelhantes?**

### Perguntas de Apoio

*  **É possível comparar um aluno com a turma e ter uma visão inicial de sua posição?**

*  **Existem diferença na defasagem final dentro de subgrupos específicos?**

# Lista de Atividades

- [ ]  Subir os arquivos para o Geminni para extração de primeiros insigths (Bianca)
- [ ]  Leitura dos arquivos do Drive - Camila, Nath, Bia.
- Desvendando Passos (Arquivo) - Nath
- Dicionário de Dados (Arquivo) - Bianca
- PEDE_ Pontos importantes (Arquivo) - Bianca
- Relatório - 2020 (Nath)
- Relatório - 2021 (Camila)
- Relatório - 2022 (Bia)
- Indicadores - Autoavaliação, Psicopedagógico, Psicossocial - Camila, Nath, Bia, Bianca
- [ ]  Análise Exploratória dos Dados - Bianca,  Camila, Nath, Bia
- Limpeza de Dados - Bianca & Nath & Bia
- Refatorar (Se necessário) - Camila
- [ ]  Verificação da qualidade das bases de dados finais
- Validação dos Insights gerados
- [ ]  Storytelling
- Montar uma história com nossos dados
"""

# @title Sheets Online
import pandas as pd
# Consulta o Sheets hospedado
abas = ['PEDE2022', 'PEDE2023', 'PEDE2024']
url = 'https://docs.google.com/spreadsheets/d/1cHUczLScbdJBJF59Z4bVg8K3hb6-0jSudtrdFDWNItQ/export?format=xlsx'
dados = pd.read_excel(url, sheet_name=abas)

# # Acessar cada uma

df_PEDE2022 = dados['PEDE2022']
df_PEDE2023 = dados['PEDE2023']
df_PEDE2024 = dados['PEDE2024']

"""# Explorando os dados - Camila
- Explorei a base PEDE 2022.
"""

df_PEDE2022

"""### Checagem da Qualidade dos Dados"""

# Checado se existem dados faltantes por coluna

df_PEDE2022.isna().sum()

#Checagem na % de dados faltantes

(df_PEDE2022.isna().mean()*100).round(2)

#Checagem nas linhas duplicadas

df_PEDE2022.duplicated().sum()

#Dimensões dos dados

df_PEDE2022.shape

# tipos, nulls e memória

df_PEDE2022.info()

# nomes das colunas

df_PEDE2022.columns.tolist()

"""### Identificando possíveis colunas problemáticas"""

# Valores nulos
df_PEDE2022.isna().sum().sort_values(ascending=False)

# Análise inicial - Talvez, tais campos não sejam problema, uma vez que os alunos podem não ter sido avaliados.

# Tipos de dados
df_PEDE2022.dtypes.value_counts()

"""### Tratamento inicial"""

df_PEDE2022.isna().sum()
(df_PEDE2022.isna().mean() * 100).round(2)

df_PEDE2022['Ano ingresso'] = pd.to_datetime(df_PEDE2022['Ano ingresso'], format='%Y', errors='coerce')

df_PEDE2022['Ano ingresso'] = df_PEDE2022['Ano ingresso'].dt.year

df_PEDE2022['Ano ingresso'].dtype

"""### Métricas de Comparação

### Camila

O que pensei, durante a análise do PEDE 2022:

Comparar desempenho individual → medir como cada aluno se posiciona em relação à média ou distribuição da turma.

Defasagens → identificar se há grupos (ex.: por sexo, escola, turno, faixa etária, localidade etc.) com desempenho abaixo da média geral.

### Etapa 1 - Criar métricas de comparação
"""

df_PEDE2022['media_geral'] = df_PEDE2022[['Matem', 'Portug']].mean(axis=1)
df_PEDE2022['media_geral']

# média e desvio padrão por turma

df_PEDE2022['media_turma'] = df_PEDE2022.groupby('Turma')['media_geral'].transform('mean')
df_PEDE2022['std_turma'] = df_PEDE2022.groupby('Turma')['media_geral'].transform('std')

df_PEDE2022['media_turma']

# z-score: quão distante o aluno está da média da turma
df_PEDE2022['z_turma'] = (df_PEDE2022['media_geral'] - df_PEDE2022['media_turma']) / df_PEDE2022['std_turma']

df_PEDE2022['z_turma']

"""| z_turma | Interpretação     | Significado                    |
| ------- | ----------------- | ------------------------------ |
| **0**   | na média da turma | desempenho igual à média       |
| **+1**  | 1 desvio acima    | melhor que ~84% da turma       |
| **+2**  | 2 desvios acima   | top 2,5% da turma              |
| **-1**  | 1 desvio abaixo   | pior que ~84% da turma         |
| **-2**  | 2 desvios abaixo  | desempenho bem abaixo da média |

"""

# Percentil do Aluno - Quantos % ele está melhor que o resto da turma?

df_PEDE2022['percentil_turma'] = df_PEDE2022.groupby('Turma')['media_geral'].rank(pct=True)
df_PEDE2022['percentil_turma']

"""### Etapa 2 - Comparar grupos e subgrupos"""

agrupado = (
    df_PEDE2022.groupby(['Turma','Gênero'])
      .agg(media=('media_geral','mean'),
           std=('media_geral','std'),
           n=('media_geral','count'))
      .reset_index()
)

agrupado

import seaborn as sns
import matplotlib.pyplot as plt

sns.barplot(data=agrupado, x='Turma', y='media', hue='Gênero')
plt.title("Média por turma e gênero")
plt.show()

"""### Etapa 3 - Identificar defasagens dentro de subgrupos"""

media_geral = df_PEDE2022['media_geral'].mean()
agrupado['defasagem'] = agrupado['media'] - media_geral

# Filtragem
agrupado_defasados = agrupado[agrupado['defasagem'] < 0]
agrupado_defasados

"""### Etapa 4 - Gerar indicadores de desigualdade"""

cv = df_PEDE2022.groupby('Turma')['media_geral'].std() / df_PEDE2022.groupby('Turma')['media_geral'].mean()
cv

"""### Algumas visualizações"""

sns.boxplot(data=df_PEDE2022, x='Gênero', y='media_geral', hue='Turma')
plt.title("Comparação de notas por sexo e turma")
plt.show()

## Padrões

sns.scatterplot(data=df_PEDE2022, x='Matem', y='Portug', hue='Turma')
plt.title("Relação entre notas nas disciplinas")
plt.show()

"""### Relatórios"""



"""#### 2022
**População:** estudantes da rede pública e bolsistas atendidos.
**Cobertura temporal:** série histórica 2020–2022 (o documento de referência é 2022).



**Principais insights**
* **Geral**
  * Maioria de escolas públicas (≈85%) e concentração no Fundamental I/II (≈82%)

  * 30% em defasagem de nível, sendo Matemática e Inglês são dores críticas

  * ~68% completam todas as provas

  * Veteranos com 2+ anos reportam **maior motivação**, além da retenção ser maior em níveis superiores.

  * Suporte emocional correlaciona com avanços acadêmicos.

* **Classificação Pedras:**
  * Topázio - alto desempenho

  * Ametista - acima da média

  * Ágata - em recuperação

  * Quartzo - em risco

# Clusterização por Padrões - Bea

- Topázio — desempenho avançado/excelente
- Ametista — bom/acima da média, base consolidada
- Ágata — em recuperação/abaixo da média, com lacunas
- Quartzo — em risco, com defasagens mais acentuadas
"""

sns.countplot(data=df_24, x='Pedra_2024', hue='fase_ideal_aj')
plt.title("Distribuição de Clusters por Pedra")
# plt.xlabel("Pedra")
# plt.ylabel("Quantidade de alunos")
# plt.legend(title="Cluster")
plt.show()

df_24['Pedra 2024'].unique()

pip install unidecode

pip install kmodes

df_PEDE2024.info()
df_PEDE2024.head()

from unidecode import unidecode

# testando função
x = -3
defasagem_aj(x)

# @title funções usadas
from pandas.api.types import CategoricalDtype
def categorizar_escola(nome_escola, tipo_instituicao):
    if pd.isnull(nome_escola):
        return 'Desconhecido'

    nome = nome_escola.lower()

    # 1. Concluiu o ensino médio ou já é universitário
    if 'concluiu' in nome or 'formado' in nome or 'universidade' in nome or 'faculdade' in nome:
        return 'Ex-aluno'

    # 2. Estuda em outra cidade: vamos usar a coluna 'instituicao_publica'
    if 'estuda em outra cidade' in nome:
        if tipo_instituicao == 'Pública':
            return 'Pública'
        elif tipo_instituicao == 'Privada - Bolsa':
            return 'Privada - Bolsa'
        else:
            return 'Privada'

    # 3. Bolsa ou programa (baseado no tipo de instituição)
    if tipo_instituicao == 'Privada - Bolsa':
        return 'Privada - Bolsa'

    # 4. Identificação direta pelo nome da escola
    if nome.startswith('em') or nome.startswith('ee'):
        return 'Pública'

    if 'colégio' in nome or 'rede' in nome:
        return 'Privada'

    return 'Outro'


def defasagem_aj(value):
  if value >= 0:
     return 'Em fase'
  elif value < -2:
    return 'Severa'
  elif value < 0:
    return 'Moderada'


# Para padronizar fase
def extrair_fase(fase):
    if pd.isnull(fase):
        return 'Desconhecido'

    fase = str(fase).strip().upper()

    if fase == 'ALFA':
        return 'ALFA'

    if fase[0].isdigit():
        return f'Fase {fase[0]}'

    return 'Outro'

  # Ordenar Pedras por Nivel
ordem_pedra = CategoricalDtype(
    categories=['Topázio', 'Ametista', 'Agata', 'Quartzo'],
    ordered=True
)

#@title Ajustando colunas categoricas para modelo
df_24 = df_PEDE2024.copy()

 #igualando coluna da fase
df_24[['fase_ideal_aj', 'Ideal']] = df_24['Fase Ideal'].str.split("(", n=1, expand=True)



# padronizar col de instituição
# df_24['instituicao_formatada'] = df_24['Instituição de ensino'].apply(
#     lambda x: unidecode(str(x)).lower())
# df_24['instituicao_publica'] = df_24['instituicao_formatada'].str.contains('publica')

df_24['tipo_instituicao_aj'] = df_24.apply(
    lambda row: categorizar_escola(row['Escola'], row['Instituição de ensino']),axis=1)

# Ajustando Defasagem para categorização - Seguindo classificação usada no PEDE2024 pag 129
df_24['defasagem_aj'] = df_24['Defasagem'].apply(defasagem_aj)

# Ajustando col Fase para igualar nomeclaturas a Fase Ideal
df_24['fase_aj'] = df_24['Fase'].apply(extrair_fase)

# Ajustando col Pedra 2024 - padronizada e ordenada
df_24['Pedra_2024'] = df_24['Pedra 2024'].str.capitalize().astype(ordem_pedra)

#removendo a coluna adicional e outras irrelevantes nesse momento
df_24.drop(labels=['Ideal','Fase Ideal','Escola','Ativo/ Inativo.1','Ativo/ Inativo'], axis=1, inplace=True)


df_24.head(2)

df_24['Pedra_2024'].value_counts()

# @title Aplicando modelo
from sklearn.preprocessing import OneHotEncoder
import pandas as pd


# Selecionei algumas colunas que acredito que podem conter padrões identificaveis em subgrupos
df_convert = df_24.copy()
cols_to_convert = ['Gênero','fase_ideal_aj','fase_aj','tipo_instituicao_aj','defasagem_aj']
df_convert[cols_to_convert] = df_convert[cols_to_convert].astype(str)
df_final = df_24[cols_to_convert]

encoder = OneHotEncoder()
encoded = encoder.fit_transform(df_convert[cols_to_convert])
encoded_df = pd.DataFrame(encoded.toarray(), columns=encoder.get_feature_names_out())

df_convert = pd.concat([df_24.drop(cols_to_convert, axis=1), encoded_df], axis=1)
display(df_final)

print(df_final['fase_ideal_aj'].unique())

df_final['fase_aj'].unique()

costs = []
K = range(2, 11)

for k in K:
    km = KModes(n_clusters=k, init="Huang", n_init=5, verbose=0)
    km.fit_predict(encoded_df)
    costs.append(km.cost_)

# Plotando
import matplotlib.pyplot as plt

plt.plot(K, costs, marker='o')
plt.xlabel('Número de clusters')
plt.ylabel('Custo (inércia)')
plt.title('Método do cotovelo para K-Modes')
plt.grid(True)
plt.show()

#@title aplicando modelo kmodes
from kmodes.kmodes import KModes
df_end = encoded_df.copy()
km = KModes(n_clusters=4, init='Huang', n_init=5, verbose=1)
clusters = km.fit_predict(encoded_df)
# df_2024['cluster'] = clusters
df_end['cluster'] = clusters
df_convert['cluster'] = clusters

cols_to_convert = ['Gênero','fase_ideal_aj','fase_aj','tipo_instituicao_aj','defasagem_aj']



import seaborn as sns
import matplotlib.pyplot as plt

# Criar o gráfico
ax = sns.countplot(data=df_convert, x='Pedra_2024', hue='cluster')
plt.title("Distribuição de Clusters por Pedra")
plt.xlabel("Pedra")
plt.ylabel("Quantidade de alunos")
plt.legend(title="Cluster")

# Calcular total para porcentagem
total = len(df_convert)

# Adicionar os valores e porcentagens nas barras
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            percentage = height / total * 100
            ax.text(
                bar.get_x() + bar.get_width() / 2,  # posição X centralizada
                height,                            # um pouco acima da barra
                f'{height:.0f} ({percentage:.1f}%)',
                ha='center', va='bottom', fontsize=9
            )

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Criar o gráfico
ax = sns.countplot(data=df_convert, x='Turma', hue='cluster')
plt.title("Distribuição de Clusters por Pedra")
plt.xlabel("")
plt.ylabel("")
plt.legend(title="Cluster")

# Calcular total para porcentagem
total = len(df_convert)

# Adicionar os valores e porcentagens nas barras
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            percentage = height / total * 100
            ax.text(
                bar.get_x() + bar.get_width() / 2,  # posição X centralizada
                height,                            # um pouco acima da barra
                f'{height:.0f} ({percentage:.1f}%)',
                ha='center', va='bottom', fontsize=9
            )

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
d = df_convert[df_convert['cluster'] == 3]
# Criar o gráfico
ax = sns.countplot(data=d, x='Instituição de ensino', hue='Instituição de ensino')
plt.title("Distribuição de Clusters por Pedra")
# plt.xlabel("Pedra")
plt.ylabel("Quantidade de alunos")
plt.legend(title="Cluster")

# Calcular total para porcentagem
total = len(d)

# Adicionar os valores e porcentagens nas barras
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            percentage = height / total * 100
            ax.text(
                bar.get_x() + bar.get_width() / 2,  # posição X centralizada
                height,                            # um pouco acima da barra
                f'{height:.0f} ({percentage:.1f}%)',
                ha='center', va='bottom', fontsize=9
            )

plt.tight_layout()
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt
d = df_convert[df_convert['cluster'] == 3]
# Criar o gráfico
ax = sns.countplot(data=d, x='Turma')
plt.title("Distribuição de Clusters por Pedra")
# plt.xlabel("Pedra")
plt.ylabel("Quantidade de alunos")
plt.legend(title="Cluster")

# Calcular total para porcentagem
total = len(d)

# Adicionar os valores e porcentagens nas barras
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            percentage = height / total * 100
            ax.text(
                bar.get_x() + bar.get_width() / 2,  # posição X centralizada
                height,                            # um pouco acima da barra
                # f'{height:.0f} ({percentage:.1f}%)',
                ha='center', va='bottom', fontsize=9
            )

plt.tight_layout()
plt.show()

d = df_convert[df_convert['cluster'] == 2]
# Criar o gráfico
ax = sns.countplot(data=d, x='Turma')
plt.title("Distribuição de Clusters por Pedra")
# plt.xlabel("Pedra")
plt.ylabel("Quantidade de alunos")
plt.legend(title="Cluster")

# Calcular total para porcentagem
total = len(d)

# Adicionar os valores e porcentagens nas barras
for container in ax.containers:
    for bar in container:
        height = bar.get_height()
        if height > 0:
            percentage = height / total * 100
            ax.text(
                bar.get_x() + bar.get_width() / 2,  # posição X centralizada
                height,                            # um pouco acima da barra
                # f'{height:.0f} ({percentage:.1f}%)',
                ha='center', va='bottom', fontsize=9
            )

plt.tight_layout()
plt.show()

display(df_convert[df_convert['cluster'] == 0])

display(df_2024[df_2024['cluster'] == 2][['Idade', 'INDE 2024', 'instituicao_publica_True','Pedra 2024']])

df24 = df_PEDE2024.copy()
df_fil24 = df24[(df24['Pedra 2024'] == 'Ametista')]
for col in df_fil24.select_dtypes(include='number').columns:
    fig = px.histogram(df_fil24, x=col, title=f'Histograma de {col}')
    fig.show()

df23 = df_PEDE2023.copy()
df_fil23 = df23[(df23['Pedra 2023'] == 'Ametista')]
df_fil23.describe()